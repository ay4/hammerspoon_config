#+title: Dalet Config
#+property: header-args:lua :tangle ./init.lua :mkdirp yes
#+STARTUP: overview

* Automatic config reload
Will automatically reload config file when init.lua has been updated. This means it will automatically be reloaded when this org file is tangled!

#+begin_src lua
function reloadConfig(files)
    doReload = false
    for _,file in pairs(files) do
        if file:sub(-4) == ".lua" then
            doReload = true
        end
    end
    if doReload then
        hs.reload()
    end
end
myWatcher = hs.pathwatcher.new(os.getenv("HOME") .. "/.hammerspoon/", reloadConfig):start()
hs.alert.show("Hammerspoon: Config Loaded")

#+end_src

* HYPER key
On *laptop*, my CapsLock should serve as ctrl+option+shift. On the main keyboard, it's ctrl+cmd+shift which is needed for different window management on both. The main keyboard is condifgured via QMK.

** Dirty Mac Hack
This line of code will remap capslock to F18 using an internal mac method. There's no other way to remap capslock unless one uses Karabiner.

#+begin_src lua
hs.execute("hidutil property --set '{\"UserKeyMapping\":[{\"HIDKeyboardModifierMappingSrc\":0x700000039,\"HIDKeyboardModifierMappingDst\":0x70000006D}]}'")
#+end_src

** Defining a modal

'hyper' will now become a mode, essentially a namespace for further hotkeys. It will be activated when CapsLock ('f18') is pressed and deactivated when it's depressed. So, all hotkeys in this namespace will only work when it's pressed. Look more in the [[https://www.hammerspoon.org/docs/hs.hotkey.modal.html][docs]].

#+begin_src lua
hyper = hs.hotkey.modal.new({}, nil)

hyper.pressed = function()
  hyper:enter()
end

hyper.released = function()
  hyper:exit()
end

hs.hotkey.bind({}, 'F18', hyper.pressed, hyper.released)
#+end_src

** Dirty hack inside a modal
We will now run a loop over a string called useful_chars and within this loop add each char to the hyper modal. The outcome of this will be that MacOS will perceive capslock+any of these chars and cmd+shift+ctrl+the same char. This will allow to set up casplock-based hotkeys in any native app.

Notably, any other symbol won't work for this.

#+begin_src lua
local useful_chars="abcdefghijklmnopqrstuvwxyz0123456789"

for i=1, #useful_chars do
   local c = useful_chars:sub(i,i)
    hyper:bind({}, c, function()
        hs.eventtap.event.newKeyEvent({"shift", "ctrl", "alt"}, c, true):post()
        hs.eventtap.event.newKeyEvent({"shift", "ctrl", "alt"}, c, false):post()
    end)
end
#+end_src

* F keys launchers
Let's have F-keys launch some useful apps

#+begin_src lua
-- F5 -> Apple Calendar
hs.hotkey.bind({}, "f5", function()
    hs.application.launchOrFocus("Calendar")
end)

-- F6 -> Telegram
hs.hotkey.bind({}, "f6", function()
    hs.application.launchOrFocus("Telegram")
end)

-- F7 -> Telegram Lite
hs.hotkey.bind({}, "f7", function()
    hs.application.launchOrFocus("Telegram Lite")
end)

-- F8 -> Open Obsidian TODO
hs.hotkey.bind({}, "f8", function()
    hs.urlevent.openURL("obsidian://open?vault=neosidian&file=TODO")
end)

-- F9 -> Mail
hs.hotkey.bind({}, "f9", function()
    hs.application.launchOrFocus("Spark")
end)

-- F10 -> Safari
hs.hotkey.bind({}, "f10", function()
    hs.application.launchOrFocus("Safari")
end)

-- F11 -> Sublime
hs.hotkey.bind({}, "f11", function()
    hs.application.launchOrFocus("Sublime Text")
end)

-- F12 -> Warp
hs.hotkey.bind({}, "f12", function()
    hs.application.launchOrFocus("Warp")
end)
#+end_src

* F4 closes an app
Like retro good old times.
#+begin_src lua
-- F4 -> Cmd+Q (Quit frontmost app)
hs.hotkey.bind({}, "f4", function()
    -- Send Command+Q to the currently focused app
    hs.eventtap.keyStroke({"cmd"}, "q")
end)
#+end_src    


* Horizontal mouse scroll switches tabs
    
#+begin_src lua
local eventtap = require("hs.eventtap")
local keyStroke = eventtap.keyStroke
local eventTypes = eventtap.event.types
local eventProps = eventtap.event.properties

-- tweakables:
local cooldownSeconds = 0.25        -- how long to wait before allowing next tab switch
local minHorizontalDelta = 2        -- how "hard" I have to scroll sideways
                                     -- higher number = less sensitive

local lastFired = 0

local scrollTap = eventtap.new({ eventTypes.scrollWheel }, function(e)
    -- read scroll deltas
    local dx = e:getProperty(eventProps.scrollWheelEventDeltaAxis2) or 0 -- horizontal
    local dy = e:getProperty(eventProps.scrollWheelEventDeltaAxis1) or 0 -- vertical

    -- only react if horizontal is dominant AND big enough
    if math.abs(dx) <= math.abs(dy) then
        return false -- it's mostly vertical scrolling, ignore
    end
    if math.abs(dx) < minHorizontalDelta then
        return false -- tiny accidental nudge, ignore
    end

    -- cooldown so we don't rapid-fire
    local now = hs.timer.secondsSinceEpoch()
    if now - lastFired < cooldownSeconds then
        return true -- swallow during cooldown so it doesn't sideways-scroll either
    end
    lastFired = now

    -- decide which tab direction
    if dx > 0 then
        -- scroll left -> previous tab
        keyStroke({"cmd", "shift"}, "[", 0)
    elseif dx < 0 then
        -- scroll right -> next tab
        keyStroke({"cmd", "shift"}, "]", 0)
    end

    -- swallow the original horizontal scroll so apps don't pan sideways
    return true
end)

scrollTap:start()
#+end_src   



* Volume Control
On normal mechanical keyboard we want Home, Scroll Lock and Pause to act like Mute, Volume down and Volume up respectively.
#+begin_src lua
local function sendSystemKey(key)
    hs.eventtap.event.newSystemKeyEvent(key, true):post()
    hs.eventtap.event.newSystemKeyEvent(key, false):post()
end

local volume = {
    up   = function() sendSystemKey("SOUND_UP") end,
    down = function() sendSystemKey("SOUND_DOWN") end,
    mute = function() sendSystemKey("MUTE") end,
}
hs.hotkey.bind({}, "f13", volume.mute)
hs.hotkey.bind({}, "f14", volume.down, nil, volume.down)
hs.hotkey.bind({}, "f15", volume.up, nil, volume.up)
#+end_src

* Switching layouts

- Command+Shift+1 = English
- Commad+Shift+2 = Russian

Notably if the layout names change, this will seize to work.

#+begin_src lua

hs.hotkey.bind({"cmd","alt"} , 18, function()
    hs.keycodes.setLayout("ABC")
end)


hs.hotkey.bind({"cmd","alt"}, 19, function()
    hs.keycodes.setLayout("Russian â€“ PC")
end)
#+end_src


* Window management

** Defining grid

If this grid changes, everything will stop working because lower the values of specific window positions are hardcoded, i.e. not calculated from the grid.

#+begin_src lua
hs.grid.setGrid('12x8')

 function moveWin(cell, window)
    window = hs.window.focusedWindow()
    hs.grid.set(window, cell, screen)
end
#+end_src

** Maximizing shortcut
Actually, two: for laptop and for main keyboard.

#+begin_src lua
hs.hotkey.bind({"ctrl", "shift", "cmd"}, "w", function() hs.grid.maximizeWindow() end)
hs.hotkey.bind({"ctrl", "shift", "alt"}, "w", function() hs.grid.maximizeWindow() end)
#+end_src

** Laptop

*** Halves
#+begin_src lua

laptop_left_half={
x = 0,
y = 0,
w = 6,
h = 8
}

laptop_right_half={
x = 6,
y = 0,
w = 6,
h = 8
}

hs.hotkey.bind({"ctrl", "shift", "alt"}, "a", function() moveWin(laptop_left_half) end)
hs.hotkey.bind({"ctrl", "shift", "alt"}, "d", function() moveWin(laptop_right_half) end)

#+end_src

*** Center
#+begin_src lua
laptop_center={
x = 2,
y = 1,
w = 9,
h = 6
}

hs.hotkey.bind({"ctrl", "shift", "alt"}, "s", function() moveWin(laptop_center) end)

#+end_src


*** Messengers
#+begin_src lua
laptop_messenger_top={
x = 0,
y = 0,
w = 2,
h = 4
}

laptop_messenger_bottom={
x = 0,
y = 4,
w = 2,
h = 4
}

hs.hotkey.bind({"ctrl", "shift", "alt"}, "q", function() moveWin(laptop_messenger_top) end)
hs.hotkey.bind({"ctrl", "shift", "alt"}, "z", function() moveWin(laptop_messenger_bottom) end)
#+end_src


** Desktop
*** Messengers
#+begin_src lua
desktop_messenger_top={
x = 0,
y = 0,
w = 2,
h = 4
}

desktop_messenger_bottom={
x = 0,
y = 4,
w = 2,
h = 4
}


hs.hotkey.bind({"ctrl", "shift", "cmd"}, "q", function() moveWin(desktop_messenger_top) end)
hs.hotkey.bind({"ctrl", "shift", "cmd"}, "z", function() moveWin(desktop_messenger_bottom) end)
#+end_src

*** Tops
    #+begin_src lua
        desktop_top={
        x = 2,
        y = 0,
        w = 8,
        h = 1
        }

        desktop_bottom={
        x = 2,
        y = 7,
        w = 8,
        h = 1
        }
        hs.hotkey.bind({"ctrl", "shift", "cmd"}, "1", function() moveWin(desktop_top) end)
        hs.hotkey.bind({"ctrl", "shift", "cmd"}, "2", function() moveWin(desktop_bottom) end)

    #+end_src
*** Centers
#+begin_src lua

desktop_center_left={
x = 2,
y = 1,
w = 4,
h = 6
}

desktop_center_right={
x = 6,
y = 1,
w = 4,
h = 6
}

desktop_center_center={
x = 3,
y = 2,
w = 6,
h = 4
}

hs.hotkey.bind({"ctrl", "shift", "cmd"}, "a", function() moveWin(desktop_center_left) end)
hs.hotkey.bind({"ctrl", "shift", "cmd"}, "d", function() moveWin(desktop_center_right) end)
hs.hotkey.bind({"ctrl", "shift", "cmd"}, "s", function() moveWin(desktop_center_center) end)

#+end_src

*** File managers
#+begin_src lua
desktop_manager_top={
x = 10,
y = 0,
w = 2,
h = 4
}

desktop_manager_bottom={
x = 10,
y = 4,
w = 2,
h = 4
}


hs.hotkey.bind({"ctrl", "shift", "cmd"}, "e", function() moveWin(desktop_manager_top) end)
hs.hotkey.bind({"ctrl", "shift", "cmd"}, "x", function() moveWin(desktop_manager_bottom) end)
#+end_src

*** Keynote
#+begin_src lua
desktop_keynote={
x = 2,
y = 0,
w = 8,
h = 8
}


hs.hotkey.bind({"ctrl", "shift", "cmd"}, "k", function() moveWin(desktop_keynote) end)
#+end_src

*** Vertical text editor
#+begin_src lua
desktop_vertical={
x = 4,
y = 1,
w = 4,
h = 6
}


hs.hotkey.bind({"ctrl", "shift", "cmd"}, "v", function() moveWin(desktop_vertical) end)
#+end_src

* Hiding application
...instead of minimizng it.

#+begin_src lua
hs.hotkey.bind({"cmd"}, "M", function()
  local currentapp=hs.application.frontmostApplication()
  currentapp:hide()
end)
#+end_src

* Close all apps fia cmd+F4
#+begin_src lua
local function quitAllNormalApps()
    local running = hs.application.runningApplications()

    for _, app in ipairs(running) do
        local name = app:name() or ""

        -- protect core stuff
        if name ~= "Hammerspoon" and name ~= "Finder" then
            -- treat "normal app" as: it currently has at least one normal window
            local wins = app:allWindows() or {}

            if #wins > 0 then
                -- request a normal quit (not force kill -9)
                app:kill()
            end
        end
    end
end

-- Bind Cmd+F4 to quit everything
hs.hotkey.bind({"cmd"}, "f4", quitAllNormalApps)
#+end_src

* Launch and position both messengers via cmd+f6
#+begin_src lua
-- helper to move a window to a given grid cell on its current screen
function placeWindowInCell(cell, win)
    win = win or hs.window.frontmostWindow()
    if not win then return end

    local scr = win:screen()
    hs.grid.set(win, cell, scr)
end

-- grid cells for messenger layout
local desktop_messenger_top = { x = 0, y = 0, w = 2, h = 4 }
local desktop_messenger_bottom = { x = 0, y = 4, w = 2, h = 4 }

-- launch/focus an app, wait for its main window to exist, then position it
local function positionApp(appName, cell)
    -- launch if needed / focus if already running
    hs.application.launchOrFocus(appName)

    local tries = 0
    local pollTimer = nil

    pollTimer = hs.timer.doEvery(0.2, function()
        tries = tries + 1

        local app = hs.appfinder.appFromName(appName)
        if app then
            local win = app:mainWindow()

            if win then
                win:unminimize()
                win:raise()
                placeWindowInCell(cell, win)

                pollTimer:stop()
                pollTimer = nil
                return
            end
        end

        -- give up after ~10 seconds (50 * 0.2s)
        if tries > 50 then
            pollTimer:stop()
            pollTimer = nil
        end
    end)
end

-- main combo action: place Telegram + Telegram Lite
local function arrangeMessengers()
    positionApp("Telegram",      desktop_messenger_top)
    positionApp("Telegram Lite", desktop_messenger_bottom)
end

-- hotkeys
hs.hotkey.bind({"cmd"}, "f6", arrangeMessengers)

hs.hotkey.bind({"ctrl", "shift", "cmd"}, "q", function()
    placeWindowInCell(desktop_messenger_top)
end)

hs.hotkey.bind({"ctrl", "shift", "cmd"}, "z", function()
    placeWindowInCell(desktop_messenger_bottom)
end)

#+end_src

* Middle mouth scrolling (disabled)

-- id of mouse wheel button
local mouseScrollButtonId = 2

-- scroll speed and direction config
local scrollSpeedMultiplier = 0.1
local scrollSpeedSquareAcceleration = true
local reverseVerticalScrollDirection = true
local mouseScrollTimerDelay = 0.01

-- circle config
local mouseScrollCircleRad = 10
local mouseScrollCircleDeadZone = 5

------------------------------------------------------------------------------------------

local mouseScrollCircle = nil
local mouseScrollTimer = nil
local mouseScrollStartPos = 0
local mouseScrollDragPosX = nil
local mouseScrollDragPosY = nil

overrideScrollMouseDown = hs.eventtap.new({ hs.eventtap.event.types.otherMouseDown }, function(e)
    -- uncomment line below to see the ID of pressed button
    --print(e:getProperty(hs.eventtap.event.properties['mouseEventButtonNumber']))

    if e:getProperty(hs.eventtap.event.properties['mouseEventButtonNumber']) == mouseScrollButtonId then
        -- remove circle if exists
        if mouseScrollCircle then
            mouseScrollCircle:delete()
            mouseScrollCircle = nil
        end

        -- stop timer if running
        if mouseScrollTimer then
            mouseScrollTimer:stop()
            mouseScrollTimer = nil
        end

        -- save mouse coordinates
        mouseScrollStartPos = hs.mouse.getAbsolutePosition()
        mouseScrollDragPosX = mouseScrollStartPos.x
        mouseScrollDragPosY = mouseScrollStartPos.y

        -- start scroll timer
        mouseScrollTimer = hs.timer.doAfter(mouseScrollTimerDelay, mouseScrollTimerFunction)

        -- don't send scroll button down event
        return true
    end
end)

overrideScrollMouseUp = hs.eventtap.new({ hs.eventtap.event.types.otherMouseUp }, function(e)
    if e:getProperty(hs.eventtap.event.properties['mouseEventButtonNumber']) == mouseScrollButtonId then
        -- send original button up event if released within 'mouseScrollCircleDeadZone' pixels of original position and scroll circle doesn't exist
        mouseScrollPos = hs.mouse.getAbsolutePosition()
        xDiff = math.abs(mouseScrollPos.x - mouseScrollStartPos.x)
        yDiff = math.abs(mouseScrollPos.y - mouseScrollStartPos.y)
        if (xDiff < mouseScrollCircleDeadZone and yDiff < mouseScrollCircleDeadZone) and not mouseScrollCircle then
            -- disable scroll mouse override
            overrideScrollMouseDown:stop()
            overrideScrollMouseUp:stop()

            -- send scroll mouse click
            hs.eventtap.otherClick(e:location(), mouseScrollButtonId)

            -- re-enable scroll mouse override
            overrideScrollMouseDown:start()
            overrideScrollMouseUp:start()
        end

        -- remove circle if exists
        if mouseScrollCircle then
            mouseScrollCircle:delete()
            mouseScrollCircle = nil
        end

        -- stop timer if running
        if mouseScrollTimer then
            mouseScrollTimer:stop()
            mouseScrollTimer = nil
        end

        -- don't send scroll button up event
        return true
    end
end)

overrideScrollMouseDrag = hs.eventtap.new({ hs.eventtap.event.types.otherMouseDragged }, function(e)
    -- sanity check
    if mouseScrollDragPosX == nil or mouseScrollDragPosY == nil then
        return true
    end

    -- update mouse coordinates
    mouseScrollDragPosX = mouseScrollDragPosX + e:getProperty(hs.eventtap.event.properties['mouseEventDeltaX'])
    mouseScrollDragPosY = mouseScrollDragPosY + e:getProperty(hs.eventtap.event.properties['mouseEventDeltaY'])

    -- don't send scroll button drag event
    return true
end)

function mouseScrollTimerFunction()
    -- sanity check
    if mouseScrollDragPosX ~= nil and mouseScrollDragPosY ~= nil then
        -- get cursor position difference from original click
        xDiff = math.abs(mouseScrollDragPosX - mouseScrollStartPos.x)
        yDiff = math.abs(mouseScrollDragPosY - mouseScrollStartPos.y)

        -- draw circle if not yet drawn and cursor moved more than 'mouseScrollCircleDeadZone' pixels
        if mouseScrollCircle == nil and (xDiff > mouseScrollCircleDeadZone or yDiff > mouseScrollCircleDeadZone) then
            mouseScrollCircle = hs.drawing.circle(hs.geometry.rect(mouseScrollStartPos.x - mouseScrollCircleRad, mouseScrollStartPos.y - mouseScrollCircleRad, mouseScrollCircleRad * 2, mouseScrollCircleRad * 2))
            mouseScrollCircle:setStrokeColor({["red"]=0.3, ["green"]=0.3, ["blue"]=0.3, ["alpha"]=1})
            mouseScrollCircle:setFill(false)
            mouseScrollCircle:setStrokeWidth(1)
            mouseScrollCircle:show()
        end

        -- send scroll event if cursor moved more than circle's radius
        if xDiff > mouseScrollCircleRad or yDiff > mouseScrollCircleRad then
            -- get real xDiff and yDiff
            deltaX = mouseScrollDragPosX - mouseScrollStartPos.x
            deltaY = mouseScrollDragPosY - mouseScrollStartPos.y

            -- use 'scrollSpeedMultiplier'
            deltaX = deltaX * scrollSpeedMultiplier
            deltaY = deltaY * scrollSpeedMultiplier

            -- square for better scroll acceleration
            if scrollSpeedSquareAcceleration then
                -- mod to keep negative values
                deltaXDirMod = 1
                deltaYDirMod = 1

                if deltaX < 0 then
                    deltaXDirMod = -1
                end
                if deltaY < 0 then
                    deltaYDirMod = -1
                end

                deltaX = deltaX * deltaX * deltaXDirMod
                deltaY = deltaY * deltaY * deltaYDirMod
            end

            -- math.ceil / math.floor - scroll event accepts only integers
             deltaXRounding = math.ceil
             deltaYRounding = math.ceil

             if deltaX < 0 then
                 deltaXRounding = math.floor
             end
             if deltaY < 0 then
                 deltaYRounding = math.floor
             end

             deltaX = deltaXRounding(deltaX)
             deltaY = deltaYRounding(deltaY)

            -- reverse Y scroll if 'reverseVerticalScrollDirection' set to true
            if reverseVerticalScrollDirection then
                deltaY = deltaY * -1
            end

            -- send scroll event
            hs.eventtap.event.newScrollEvent({-deltaX, deltaY}, {}, 'pixel'):post()
        end
    end

    -- restart timer
    mouseScrollTimer = hs.timer.doAfter(mouseScrollTimerDelay, mouseScrollTimerFunction)
end

-- start override functions
overrideScrollMouseDown:start()
overrideScrollMouseUp:start()
overrideScrollMouseDrag:start()
